<div id="madhabam-tide-widget" style="max-width:300px;">

</div>


<script>

/* TIDE WIDGET - STANDALONE (Final Compact Dynamic UI - Responsiveness Fixed) */

(function(){

┬а┬а┬а┬а// API Endpoints and Default Location (Kolkata)
┬а┬а┬а┬аconst API_OM = 'https://api.open-meteo.com/v1/forecast';
┬а┬а┬а┬аconst API_IP = 'https://ipapi.co/json/';
┬а┬а┬а┬аconst DEFAULT = { lat:22.57, lng:88.36, source:'рж╕рзНржерж┐рж░ рж╕рзНржерж╛ржирж╛ржЩрзНржХ', city:'ржХрж▓ржХрж╛рждрж╛' };
┬а┬а┬а┬аconst $ = id => document.getElementById(id);
┬а┬а┬а┬а
┬а┬а┬а┬а// Fallback Data
┬а┬а┬а┬аconst FALLBACK_DATA = {
┬а┬а┬а┬а┬а┬а┬а┬аtide_anchor_fallback: '20:30',┬а
┬а┬а┬а┬а};

┬а┬а┬а┬а// Global STATE object to hold the fetched tide times
┬а┬а┬а┬аlet STATE = { lat: DEFAULT.lat, lng: DEFAULT.lng, source: DEFAULT.source, city: DEFAULT.city, tides:[] };
┬а┬а┬а┬аlet updateUIInterval = null;┬а
┬а┬а┬а┬аlet updateDataInterval = null;┬а
┬а┬а┬а┬а
┬а┬а┬а┬а// --- Localization and Formatting ---
┬а┬а┬а┬аfunction formatToBengali(dateInput, isTime = false, showSeconds = false) {
┬а┬а┬а┬а┬а┬а┬а┬аif (!dateInput) return 'тАФ';
┬а┬а┬а┬а┬а┬а┬а┬аtry {
┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬аconst date = (dateInput instanceof Date) ? dateInput : new Date(dateInput);
┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬аif (isNaN(date)) return 'тАФ';
┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а
┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬аconst options = { timeZone: 'Asia/Kolkata' };
┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а
┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬аif (isTime) {
┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬аoptions.hour = '2-digit';┬а
┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬аoptions.minute = '2-digit';
┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬аif (showSeconds) options.second = '2-digit';┬а
┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬аoptions.hour12 = true;
┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬аreturn date.toLocaleTimeString('bn-BD', options);
┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а}
┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬аoptions.day = '2-digit';
┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬аoptions.month = '2-digit';
┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬аoptions.year = 'numeric';
┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬аreturn date.toLocaleDateString('bn-BD', options).replace(/\//g, '-');
┬а┬а┬а┬а┬а┬а┬а┬а} catch (e) {
┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬аreturn 'тАФ';
┬а┬а┬а┬а┬а┬а┬а┬а}
┬а┬а┬а┬а}
┬а┬а┬а┬а
┬а┬а┬а┬аfunction parseBengaliTime(timeStr, dateContext) {
┬а┬а┬а┬а┬а┬а┬а┬аtry {
┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬аconst parts = timeStr.split(' ');
┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬аif (parts.length !== 2) return null;

┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬аconst [timePart, ampm] = parts;
┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬аlet [h, m] = timePart.split(':').map(Number);
┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а
┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬аif (ampm === 'PM' && h !== 12) h += 12;
┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬аif (ampm === 'AM' && h === 12) h = 0;
┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а
┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬аlet date = dateContext || new Date();
┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а// Set to today's date, but use the target time
┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬аdate = new Date(date.getFullYear(), date.getMonth(), date.getDate(), h, m, 0); 
┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬аreturn date;
┬а┬а┬а┬а┬а┬а┬а┬а} catch (e) {
┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬аreturn null;
┬а┬а┬а┬а┬а┬а┬а┬а}
┬а┬а┬а┬а}


┬а┬а┬а┬а// --- Dynamic SVG Helpers ---
┬а┬а┬а┬аfunction createWaveSVG() {
┬а┬а┬а┬а┬а┬а┬а┬аconst ns = 'http://www.w3.org/2000/svg';
┬а┬а┬а┬а┬а┬а┬а┬аconst svg = document.createElementNS(ns, 'svg');
┬а┬а┬а┬а┬а┬а┬а┬аsvg.setAttribute('width', '24'); svg.setAttribute('height', '24'); svg.setAttribute('viewBox', '0 0 24 24');

┬а┬а┬а┬а┬а┬а┬а┬аconst style = document.createElementNS(ns, 'style');
┬а┬а┬а┬а┬а┬а┬а┬аstyle.textContent = `
┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а.wave { fill: none; stroke: #FFF; stroke-width: 2; stroke-linecap: round; stroke-linejoin: round; animation: wave-motion 2s linear infinite alternate; }
┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а@keyframes wave-motion { 0% { transform: translateY(0px); } 100% { transform: translateY(-2px); } }
┬а┬а┬а┬а┬а┬а┬а┬а`;
┬а┬а┬а┬а┬а┬а┬а┬аsvg.appendChild(style);
┬а┬а┬а┬а┬а┬а┬а┬аconst path1 = document.createElementNS(ns, 'path'); path1.setAttribute('class', 'wave'); path1.setAttribute('d', 'M2 12s2-2 4-2 4 2 4 2 2-2 4-2 4 2 4 2'); svg.appendChild(path1);
┬а┬а┬а┬а┬а┬а┬а┬аconst path2 = document.createElementNS(ns, 'path'); path2.setAttribute('class', 'wave'); path2.setAttribute('d', 'M2 16s2-2 4-2 4 2 4 2 2-2 4-2 4 2 4 2'); path2.style.animationDelay = '-1s'; svg.appendChild(path2);

┬а┬а┬а┬а┬а┬а┬а┬аreturn svg.outerHTML;
┬а┬а┬а┬а}
┬а┬а┬а┬а
┬а┬а┬а┬аfunction createGlowArrow(direction, size = '1.1em') {
┬а┬а┬а┬а┬а┬а┬а┬аconst arrow = direction === 'up' ? 'тЦ▓' : 'тЦ╝';
┬а┬а┬а┬а┬а┬а┬а┬аconst color = direction === 'up' ? '#32CD32' : '#FF4500';┬а
┬а┬а┬а┬а┬а┬а┬а┬аconst shadow = `0 0 5px ${color}, 0 0 10px ${color}`;

┬а┬а┬а┬а┬а┬а┬а┬аreturn `<span style="font-size: ${size}; color: ${color}; text-shadow: ${shadow}; margin-left: 5px; position: relative; top: ${direction === 'up' ? '-2px' : '2px'};">${arrow}</span>`;
┬а┬а┬а┬а}


    // --- ЁЯЪи FIXED: Coordinates Loader (moved to global scope and improved) ---
    async function loadCoordinates() {
        let coords = { ...DEFAULT }; // Start with default
        try {
            // Try IP API for city/coords
            const r = await fetch(API_IP);
            if (r.ok) {
                const j = await r.json();
                if (j.latitude && j.longitude) {
                    coords.lat = j.latitude;
                    coords.lng = j.longitude;
                    coords.city = j.city || DEFAULT.city;
                    coords.source = 'IP API';
                }
            }
        } catch (e) {
            console.error("IP API Error, using default coords:", e);
        }

        // Try Geolocation API as a secondary option if not found or if the user allows
        if (navigator.geolocation) {
            try {
                const geo = await new Promise((resolve, reject) => {
                    navigator.geolocation.getCurrentPosition(resolve, reject, { timeout: 5000 });
                });
                coords.lat = geo.coords.latitude;
                coords.lng = geo.coords.longitude;
                coords.source = 'Geolocation';
                // Note: We keep the IP city name as it is generally more reliable for non-mobile use.
            } catch (e) {
                 // Geolocation error is non-critical, proceed with existing coords
            }
        }
        
        return coords;
    }


┬а┬а┬а┬а// --- Tide Data Approximation ---
┬а┬а┬а┬аfunction approxTides(baseTime){
┬а┬а┬а┬а┬а┬а┬а┬а
┬а┬а┬а┬а┬а┬а┬а┬аlet base = new Date();
┬а┬а┬а┬а┬а┬а┬а┬аif(baseTime && baseTime.includes('T')) base = new Date(baseTime);
┬а┬а┬а┬а┬а┬а┬а┬аelse if(baseTime) {┬а
┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬аconst d=new Date();┬а
┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а// Using parseBengaliTime for reliable base time parsing
┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬аbase = parseBengaliTime(formatToBengali(new Date(d.getFullYear(), d.getMonth(), d.getDate()) + ' ' + baseTime), new Date());
            if (!base) base = new Date();
┬а┬а┬а┬а┬а┬а┬а┬а}
┬а┬а┬а┬а┬а┬а┬а┬а
┬а┬а┬а┬а┬а┬а┬а┬аconst gap = (6 * 60 + 12) * 60000;┬а
┬а┬а┬а┬а┬а┬а┬а┬аconst out = [];
┬а┬а┬а┬а┬а┬а┬а┬аconst types = ['ржЙржЪрзНржЪ ржЬрзЛржпрж╝рж╛рж░', 'ржирж┐ржорзНржи ржнрж╛ржЯрж╛', 'ржЙржЪрзНржЪ ржЬрзЛржпрж╝рж╛рж░', 'ржирж┐ржорзНржи ржнрж╛ржЯрж╛'];┬а
┬а┬а┬а┬а┬а┬а┬а┬а
┬а┬а┬а┬а┬а┬а┬а┬аfor(let i=0; i < 4; i++){
┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬аlet t = new Date(base.getTime() + i * gap);┬а
┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬аout.push({┬а
┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬аtype: types[i],┬а
┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬аtime: formatToBengali(t, true),
┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬аlevel: (i % 2 === 0) ? 'high' : 'low',┬а
┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬аtimestamp: t.getTime()┬а
┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а});┬а
┬а┬а┬а┬а┬а┬а┬а┬а}
┬а┬а┬а┬а┬а┬а┬а┬а
┬а┬а┬а┬а┬а┬а┬а┬аreturn out.sort((a, b) => a.timestamp - b.timestamp);
┬а┬а┬а┬а}
┬а┬а┬а┬а
┬а┬а┬а┬а// --- Current Water Level Calculation (Kept as is) ---
┬а┬а┬а┬аfunction getDynamicLevelInfo(tides) {
        if (!tides || tides.length === 0) return { level: 50, direction: 'static', nextEventIndex: -1 };
        
        const now = new Date().getTime();
        let closestPastEvent = null;
        let nextEvent = null;
        let nextEventIndex = -1;

        // Find the closest past event and the immediate next event
        for(let i = 0; i < tides.length; i++) {
            if (tides[i].timestamp <= now) {
                closestPastEvent = tides[i];
                nextEvent = tides[i+1];
                nextEventIndex = i+1;
            } else if (!nextEvent) {
                nextEvent = tides[i];
                nextEventIndex = i;
            }
        }
        
        // Handle wrap-around (if the list has ended, the next event is the first one tomorrow)
        if (!nextEvent) {
            nextEvent = tides[0];┬а
            closestPastEvent = tides[tides.length - 1];┬а
            nextEventIndex = 0;
            
            // Re-calculate timestamps for next day context
            const tomorrow = new Date();
            tomorrow.setDate(tomorrow.getDate() + 1);
            
            // Use the stored Bengali time string and tomorrow's date context for correct timestamp
            const parsedTimeTomorrow = parseBengaliTime(nextEvent.time, tomorrow);
            nextEvent.timestamp = parsedTimeTomorrow ? parsedTimeTomorrow.getTime() : now + (6 * 60 * 60 * 1000); // Fallback
            
            // Check if the closest past event is still too old (e.g., from yesterday)
            const yesterdayLimit = now - (6 * 60 * 60 * 1000); // Only consider events within the last 6 hours as relevant start
            if(closestPastEvent.timestamp < yesterdayLimit) {
                closestPastEvent = null;┬а
            }
        }
        
        // Use 95% and 5% instead of 100% and 0% for visual buffer
        const levelStart = closestPastEvent && closestPastEvent.level === 'high' ? 95 : 5;
        const levelEnd = nextEvent && nextEvent.level === 'high' ? 95 : 5;
        
        let currentLevel = 50;┬а
        let direction = 'static';┬а

        // Linear Interpolation
        if (closestPastEvent && nextEvent && nextEvent.timestamp > closestPastEvent.timestamp) {
            const timeDiff = nextEvent.timestamp - closestPastEvent.timestamp;
            const levelDiff = levelEnd - levelStart;
            const timeElapsed = now - closestPastEvent.timestamp;

            // Ensure we are within the current cycle's time window
            if(timeElapsed >= 0 && timeElapsed <= timeDiff) {
                currentLevel = levelStart + (levelDiff * (timeElapsed / timeDiff));
            } else if (timeElapsed > timeDiff) {
                 // Should be exactly at the end level if interpolation missed
                 currentLevel = levelEnd;
            } else {
                currentLevel = levelStart;
            }

            
            if (levelStart === 95 && levelEnd === 5) {
                direction = 'down';┬а
            } else if (levelStart === 5 && levelEnd === 95) {
                direction = 'up';┬а
            }
        } else if (nextEvent) {
             // If closestPastEvent is null, assume we are heading towards it
             // A heuristic: set level near the destination to make the direction clear.
             if (nextEvent.level === 'high') {
                 currentLevel = 50;
                 direction = 'up';
             } else {
                 currentLevel = 50;
                 direction = 'down';
             }
        }
        
        currentLevel = Math.max(5, Math.min(95, currentLevel));┬а

        return {┬а
            level: Math.round(currentLevel),┬а
            direction: direction,┬а
            nextEventIndex: nextEventIndex┬а
        };┬а
    }


┬а┬а┬а┬а// --- Build Functions (for initial render and live updates) ---
┬а┬а┬а┬а
┬а┬а┬а┬аfunction buildTideList(tides, dynamicLevelInfo) {
┬а┬а┬а┬а┬а┬а┬а┬аlet tideListHTML = '';
┬а┬а┬а┬а┬а┬а┬а┬аconst nextEventIndex = dynamicLevelInfo.nextEventIndex;
┬а┬а┬а┬а┬а┬а┬а┬аconst currentDirection = dynamicLevelInfo.direction;

┬а┬а┬а┬а┬а┬а┬а┬аif (tides && tides.length) {
┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬аtides.forEach((t, index) => {
┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬аconst isHighlight = index === nextEventIndex;
┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬аconst highlightClass = isHighlight ? 'highlight' : '';
┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а
┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а// Show arrow direction on the type name for visual aid
                const isNextEventRelevant = isHighlight && (currentDirection === 'up' || currentDirection === 'down');
┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬аconst arrowIndicator = isNextEventRelevant ? createGlowArrow(currentDirection, '0.9em') : '';
┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а
┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬аtideListHTML += `
┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а<div class="tide-item-compact ${highlightClass}">
┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а<span class="tide-label-group">
┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а<div class="tide-icon-svg">${createWaveSVG()}</div>
┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а<div class="tide-text-stack">
┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а<span class="tide-type-value">${t.type}${arrowIndicator}</span>
┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а<span class="tide-time-value">${t.time || 'тАФ'}</span>
┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а</div>
┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а</span>
┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а</div>
┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а`;
┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а});
┬а┬а┬а┬а┬а┬а┬а┬а} else {
┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬аtideListHTML = `<div class="tide-item-compact"><span>рждржерзНржп ржкрж╛ржУрзЯрж╛ ржпрж╛рзЯржирж┐ред</span><span>тАФ</span></div>`;
┬а┬а┬а┬а┬а┬а┬а┬а}
┬а┬а┬а┬а┬а┬а┬а┬аreturn tideListHTML;
┬а┬а┬а┬а}
┬а┬а┬а┬а
┬а┬а┬а┬аfunction buildWidget(data) {
┬а┬а┬а┬а┬а┬а┬а┬а
┬а┬а┬а┬а┬а┬а┬а┬аconst currentDateBengali = formatToBengali(new Date(), false);
┬а┬а┬а┬а┬а┬а┬а┬аconst dynamicLevelInfo = getDynamicLevelInfo(data.tides);
┬а┬а┬а┬а┬а┬а┬а┬а
┬а┬а┬а┬а┬а┬а┬а┬а// --- 1. CSS Styles (Kept as is - contains wave animation) ---
┬а┬а┬а┬а┬а┬а┬а┬аconst css = `
┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а<style>
┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а#madhabam-tide-widget *{┬а
┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬аbox-sizing: border-box;┬а
┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬аfont-family: 'Noto Sans Bengali', 'Kalpurush', 'SolaimanLipi', sans-serif !important;┬а
┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬аline-height: 1.1;┬а
┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬аcolor: #333;┬а
┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а}
┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а.tide-panel {┬а
┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬аbackground-color: #006f7a;┬а
┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬аcolor: white;┬а
┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬аborder-radius: 12px;┬а
┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬аpadding: 15px;┬а
┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬аmargin-bottom: 15px;┬а
┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬аbox-shadow: 0 6px 12px rgba(0, 0, 0, 0.15);┬а
┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬аdisplay: flex;┬а
┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬аgap: 10px;┬а
┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬аheight: auto;┬а
┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬аmin-height: 350px;
┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬аoverflow: hidden;┬а
┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а}
┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а.tide-panel * { color: white !important; }
┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а
┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а.tide-content {┬а
┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬аflex-grow: 1;┬а
┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬аdisplay: flex;
┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬аflex-direction: column;
┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬аjustify-content: space-between;┬а
┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬аmin-width: 0;┬а
┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а}
┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а
┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а.tide-header-section {┬а
┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬аdisplay: flex;
┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬аjustify-content: space-between;
┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬аalign-items: flex-end;
┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬аmargin-bottom: 10px;┬а
┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а}
┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а.tide-header-title {┬а
┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬аfont-weight: 900;┬а
┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬аfont-size: 1.45em;┬а
┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬аcolor: #FFEB3B !important;┬а
┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а}
┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а
┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а.tide-events-list {┬а
┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬аflex-grow: 1;┬а
┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬аmargin-bottom: 10px;┬а
┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а}

┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а.tide-item-compact {┬а
┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬аdisplay: flex;┬а
┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬аjustify-content: space-between;┬а
┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬аalign-items: center;┬а
┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬аfont-size: 1.0em;┬а
┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬аpadding: 5px 0;┬а
┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬аmargin: 4px 0;
┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬аborder-bottom: 1px dotted rgba(255, 255, 255, 0.1);
┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬аtransition: all 0.3s;
┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬аposition: relative;
┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а}
┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а
┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а.tide-label-group {┬а
┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬аdisplay: flex;┬а
┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬аalign-items: center;┬а
┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬аgap: 5px;┬а
┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬аfont-weight: 600;┬а
┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬аwhite-space: nowrap;┬а
┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а}
┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а.tide-text-stack {
┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬аdisplay: flex;
┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬аflex-direction: column;
┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬аalign-items: flex-start;
┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬аline-height: 1;
┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬аpadding-left: 2px;
┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а}
┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а.tide-type-value {
┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬аfont-weight: 700;
┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬аfont-size: 1.1em;
┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а}
┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а.tide-time-value {┬а
┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬аfont-weight: 800;┬а
┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬аfont-size: 1.05em;┬а
┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬аcolor: #FFEB3B !important;┬а
┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬аwhite-space: nowrap;┬а
┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬аmargin-top: 2px;
┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а}┬а
┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а
┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а.tide-item-compact.highlight {
┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬аbackground-color: rgba(255, 255, 255, 0.2);┬а
┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬аborder-radius: 4px;
┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬аpadding: 6px;
┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬аmargin: 4px -6px;
┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬аbox-shadow: 0 0 8px rgba(255, 235, 59, 0.5);┬а
┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а}

┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а.footer-tags-section {
┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬аpadding-top: 10px;
┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬аborder-top: 1px solid rgba(255, 255, 255, 0.4);
┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а}
┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а.tide-date-footer {
┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬аfont-size: 0.9em;
┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬аfont-weight: 700;┬а
┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬аcolor: #A9E4FF !important;
┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬аmargin-bottom: 5px;
┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а}
┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а.location-time-tag {┬а
┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬аtext-align: left;┬а
┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬аfont-size: 0.9em;┬а
┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬аfont-weight: 600;┬а
┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а}
┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а.location-time-tag span { font-weight: 800; color: #e6c300 !important; }
┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а
┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а.level-indicator-container {
┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬аwidth: 50px;┬а
┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬аmin-width: 50px;
┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬аdisplay: flex;
┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬аflex-direction: column;
┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬аalign-items: center;
┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬аpadding-top: 10px;
┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬аpadding-bottom: 10px;
┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а}
┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а.level-indicator-bar {
┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬аflex-grow: 1;┬а
┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬аwidth: 35px;┬а
┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬аborder: 3px solid #FFFFFF;
┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬аborder-radius: 12px;
┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬аbackground-color: rgba(255, 255, 255, 0.2);
┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬аoverflow: hidden;
┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬аposition: relative;
┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а}
┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а.water-fill {
┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬аposition: absolute;
┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬аbottom: 0;
┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬аleft: 0;
┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬аwidth: 100%;
┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬аbackground: linear-gradient(to top, #A9E4FF 0%, #00BFFF 100%);┬а
┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬аtransition: height 0.5s linear; /* Linear transition for smoother flow */
┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬аborder-top: 3px solid #FFFFFF;
┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а}
┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а.water-level-text {
┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬аposition: absolute;
┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬аtop: 50%;┬а
┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬аleft: 50%;
┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬аtransform: translate(-50%, -50%);
┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬аfont-size: 0.8em;
┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬аfont-weight: 900;
┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬аcolor: #006f7a !important;┬а
┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬аz-index: 10;
┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬аtransition: opacity 0.5s;
┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а}
┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а</style>
┬а┬а┬а┬а┬а┬а┬а┬а`;
┬а┬а┬а┬а┬а┬а┬а┬а
┬а┬а┬а┬а┬а┬а┬а┬аconst initialLocalTime = formatToBengali(new Date(), true, true);
┬а┬а┬а┬а┬а┬а┬а┬аconst panelArrow = dynamicLevelInfo.direction !== 'static' ? createGlowArrow(dynamicLevelInfo.direction, '1.4em') : '';

┬а┬а┬а┬а┬а┬а┬а┬аconst tideHTML = `
┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а<div class="tide-panel">
┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а<div class="tide-content">
┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а<div class="tide-header-section">
┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а<div class="tide-header-title">ржЬрзЛржпрж╝рж╛рж░-ржнрж╛ржЯрж╛</div>
┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а<div class="level-indicator-label" style="text-align: right; margin-right: 5px;">
┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а<span id="panel-arrow-indicator">${panelArrow}</span><br>
┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а<span style="font-size: 0.7em;">ржмрж░рзНрждржорж╛ржи ржЬрж▓рж╕рзНрждрж░</span>
┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а</div>
┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а</div>
┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а
┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а<div class="tide-events-list" id="tide-events-list">${buildTideList(data.tides, dynamicLevelInfo)}</div>
┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а
┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а<div class="footer-tags-section">
┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а<div class="tide-date-footer">ржЖржЬ: ${currentDateBengali}</div>
┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а<div class="location-time-tag">
┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬арж╕рзНржерж╛ржи: <span>${data.city}</span> | рж╕рзНржерж╛ржирзАржпрж╝ рж╕ржоржпрж╝: <span id="local-time-live">${initialLocalTime}</span>
┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а</div>
┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а</div>
┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а</div>
┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а
┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а<div class="level-indicator-container">
┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а
┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а<div class="level-indicator-bar">
┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а<div class="water-level-text" id="water-level-text">${dynamicLevelInfo.level}%</div>
┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а<div class="water-fill" id="water-fill" style="height: ${dynamicLevelInfo.level}%;">
┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а</div>
┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а</div>
┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а</div>
┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а</div>
┬а┬а┬а┬а┬а┬а┬а┬а`;
┬а┬а┬а┬а┬а┬а┬а┬а
┬а┬а┬а┬а┬а┬а┬а┬аreturn css + tideHTML;
┬а┬а┬а┬а}
┬а┬а┬а┬а
┬а┬а┬а// --- UI Update Function (Runs very frequently for smooth movement) ---
┬а┬а┬а┬аfunction updateLiveUI() {
┬а┬а┬а┬а┬а┬а┬а┬а// Only run if tides data is loaded
┬а┬а┬а┬а┬а┬а┬а┬аif (STATE.tides.length === 0) return;
┬а┬а┬а┬а┬а┬а┬а┬а
┬а┬а┬а┬а┬а┬а┬а┬аconst timeElement = $('local-time-live');
┬а┬а┬а┬а┬а┬а┬а┬аif (timeElement) {
┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬аtimeElement.textContent = formatToBengali(new Date(), true, true);
┬а┬а┬а┬а┬а┬а┬а┬а}

┬а┬а┬а┬а┬а┬а┬а┬аconst fillElement = $('water-fill');
┬а┬а┬а┬а┬а┬а┬а┬аconst textElement = $('water-level-text');
┬а┬а┬а┬а┬а┬а┬а┬аconst listElement = $('tide-events-list');
┬а┬а┬а┬а┬а┬а┬а┬аconst panelArrowElement = $('panel-arrow-indicator');
┬а┬а┬а┬а┬а┬а┬а┬а
┬а┬а┬а┬а┬а┬а┬а┬аif (fillElement && textElement && listElement && panelArrowElement) {
┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬аconst dynamicLevelInfo = getDynamicLevelInfo(STATE.tides);
┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а
┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а// Update percentage and height
┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬аfillElement.style.height = `${dynamicLevelInfo.level}%`;
┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬аtextElement.textContent = `${dynamicLevelInfo.level}%`;
┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а
┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а// Rebuild the list structure to update highlighting and individual arrows
┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬аlistElement.innerHTML = buildTideList(STATE.tides, dynamicLevelInfo);
┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а
┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а// Update the main panel arrow indicator
┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬а┬аpanelArrowElement.innerHTML = dynamicLevelInfo.direction !== 'static' ? createGlowArrow(dynamicLevelInfo.direction, '1.4em') : '';
┬а┬а┬а┬а┬а┬а┬а┬а}
┬а┬а┬а┬а}


┬а┬а┬а┬а// --- Main Loader Function ---
┬а┬а┬а┬аasync function loadAllData() {
        try {
            // 1. Clear intervals
            if (updateDataInterval) clearInterval(updateDataInterval);
            if (updateUIInterval) clearInterval(updateUIInterval);
            
            // 2. Fetch Coordinates
            const coords = await loadCoordinates();
            STATE.lat = coords.lat;
            STATE.lng = coords.lng;
            STATE.source = coords.source;
            STATE.city = coords.city;
            
            // 3. Fetch Tide Anchor (Moonrise)
            let raw_moonrise = null;
            try {
                const r2 = await fetch(API_OM + `?latitude=${STATE.lat}&longitude=${STATE.lng}&daily=moonrise&timezone=auto`);
                const j2 = r2.ok ? await r2.json() : {};
                if(j2.daily && j2.daily.moonrise && j2.daily.moonrise.length && j2.daily.moonrise[0] && j2.daily.moonrise[0] !== null){
                    // Only take the time part (HH:MM:SS) after 'T'
                    raw_moonrise = j2.daily.moonrise[0].split('T')[1].substring(0, 5);
                } else {
                    raw_moonrise = FALLBACK_DATA.tide_anchor_fallback;
                }
            } catch(e) {
                console.error("Moonrise API Error, using fallback time:", e);
                raw_moonrise = FALLBACK_DATA.tide_anchor_fallback;
            }

            // 4. Approximate Tides
            STATE.tides = approxTides(raw_moonrise || new Date()); 
            
            // 5. Initial Full Render
            const targetElement = $('madhabam-tide-widget');
            if (targetElement) { 
                targetElement.innerHTML = buildWidget(STATE); 
            }
            
            // 6. Start the continuous UI update intervals (Crucial for responsiveness)
            updateUIInterval = setInterval(updateLiveUI, 100); 
            
            // 7. Set the main data refresh interval (every 30 minutes)
            updateDataInterval = setInterval(loadAllData, 1800000); 
        } catch(e) {
            console.error("Critical error in loadAllData:", e);
            const targetElement = $('madhabam-tide-widget');
            if (targetElement) {
                 targetElement.innerHTML = `<div style="padding: 15px; border: 1px solid #795548; background-color: #f7e6e3; color: #795548; border-radius: 8px;">ржЬрзЛржпрж╝рж╛рж░-ржнрж╛ржЯрж╛рж░ рждржерзНржп рж▓рзЛржб рж╣ржЪрзНржЫрзЗ ржирж╛ред ржЕржирзБржЧрзНрж░рж╣ ржХрж░рзЗ ржкрж░рзЗ ржЖржмрж╛рж░ ржЪрзЗрж╖рзНржЯрж╛ ржХрж░рзБржиред</div>`;
            }
        }
    }

    // ЁЯЪи FIXED: Wrap the initial call in DOMContentLoaded event listener 
    // This ensures the script only runs after the <div id="madhabam-tide-widget"> is available,
    // preventing the 'blank screen' issue that occurred during rapid loading or browser errors.
    document.addEventListener('DOMContentLoaded', loadAllData);
    
    // Fallback for older browsers or external embedding where DOMContentLoaded might be delayed
    if (document.readyState === 'complete' || document.readyState === 'interactive') {
        loadAllData();
    }
})();
</script>
