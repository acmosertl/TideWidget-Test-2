<div class="tide-widget">
    <div class="widget-header">
        <div class="tide-title">‡¶ú‡ßã‡¶Ø‡¶º‡¶æ‡¶∞-‡¶≠‡¶æ‡¶ü‡¶æ</div>
        <div class="level-title-flex">
            <div class="tide-title-sub">‡¶¨‡¶∞‡ßç‡¶§‡¶Æ‡¶æ‡¶® ‡¶ú‡¶≤‡¶∏‡ßç‡¶§‡¶∞</div> 
        </div>
    </div>

    <div class="tide-body-flex">
        <div id="tide-list-container" class="tide-list-container">
            <div id="loading-message" style="color: #ffeb3b; text-align: center; padding: 20px;">
                ‡¶ú‡ßã‡¶Ø‡¶º‡¶æ‡¶∞-‡¶≠‡¶æ‡¶ü‡¶æ‡¶∞ ‡¶§‡¶•‡ßç‡¶Ø ‡¶≤‡ßã‡¶° ‡¶π‡¶ö‡ßç‡¶õ‡ßá...
            </div>
        </div>

        <div class="level-indicator-wrapper">
            <div id="level-container" class="level-container">
                <div id="level-bar" class="level-bar"></div>
                <div id="level-percent" class="level-percent"></div> 
            </div>
        </div>
    </div>

    <div class="widget-footer">
        ‡¶Ü‡¶ú: <strong id="current-date-display"></strong> | 
        ‡¶∏‡ßç‡¶•‡¶æ‡¶®: <strong id="location-name">Kolakata</strong> |
        ‡¶∏‡ßç‡¶•‡¶æ‡¶®‡ßÄ‡¶Ø‡¶º ‡¶∏‡¶Æ‡¶Ø‡¶º: <strong id="local-time-display"></strong>
        
        <div id="api-key-warning" style="display: none; color: #ffeb3b; font-size: 0.8em; margin-top: 5px; padding-top: 5px; border-top: 1px solid rgba(255, 255, 255, 0.2);">
             ‡¶ú‡ßã‡¶Ø‡¶º‡¶æ‡¶∞-‡¶≠‡¶æ‡¶ü‡¶æ‡¶∞ ‡¶§‡¶•‡ßç‡¶Ø ‡¶¨‡¶∞‡ßç‡¶§‡¶Æ‡¶æ‡¶®‡ßá ‡¶≤‡ßã‡¶° ‡¶π‡¶ö‡ßç‡¶õ‡ßá ‡¶®‡¶æ (‡¶´‡¶≤‡¶¨‡ßç‡¶Ø‡¶æ‡¶ï ‡¶°‡ßá‡¶ü‡¶æ ‡¶¨‡ßç‡¶Ø‡¶¨‡¶π‡ßÉ‡¶§ ‡¶π‡¶ö‡ßç‡¶õ‡ßá)
        </div>
    </div>
</div>

<style>
/* ---------------------------------
   CSS: (‡¶Ü‡¶ó‡ßá‡¶∞ ‡¶Æ‡¶§‡ßã‡¶á ‡¶∞‡¶á‡¶≤, ‡¶∂‡ßÅ‡¶ß‡ßÅ‡¶Æ‡¶æ‡¶§‡ßç‡¶∞ ‡¶´‡¶®‡ßç‡¶ü‡ßá‡¶∞ ‡¶∏‡¶Æ‡¶∏‡ßç‡¶Ø‡¶æ ‡¶è‡¶°‡¶º‡¶æ‡¶§‡ßá)
   --------------------------------- */
.tide-widget {
    background-color: #2e5c6a; 
    border: 5px solid #795548; 
    border-radius: 12px;
    padding: 15px;
    max-width: 300px; 
    color: #ffffff;
    box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
    margin: 10px auto; 
    font-family: Arial, sans-serif; 
}

.widget-header {
    display: flex;
    justify-content: space-between;
    align-items: flex-end; 
    margin-bottom: 10px;
    gap: 10px;
}

.tide-title {
    color: #ffeb3b; 
    font-size: 1.3em;
    font-weight: bold;
    flex-grow: 1;
    text-align: left;
}

.level-title-flex {
    display: flex;
    flex-direction: column;
    align-items: flex-end;
}

.tide-title-sub {
    color: #cfd8dc; 
    font-size: 0.8em;
    font-weight: normal;
}

.tide-body-flex {
    display: flex;
    gap: 15px;
    align-items: stretch;
    min-height: 200px; 
    margin-bottom: 10px;
}

.tide-list-container {
    flex-grow: 1; 
}

.level-indicator-wrapper {
    display: flex;
    flex-direction: column;
    align-items: center;
}

.tide-entry {
    display: flex;
    justify-content: space-between; 
    align-items: center;
    padding: 8px 0;
    border-top: 1px solid rgba(255, 255, 255, 0.1);
    transition: background-color 0.3s ease;
    white-space: nowrap; 
    overflow: hidden;
}

.tide-info {
    font-size: 1.0em; 
    color: #cfd8dc; 
    flex-shrink: 0; 
    display: flex;
    align-items: center;
}

/* LHW/HLW (‡¶®‡¶ø‡¶Æ‡ßç‡¶® ‡¶ú‡ßã‡¶Ø‡¶º‡¶æ‡¶∞/‡¶â‡¶ö‡ßç‡¶ö ‡¶≠‡¶æ‡¶ü‡¶æ) ‡¶è‡¶∞ ‡¶ú‡¶®‡ßç‡¶Ø ‡¶π‡¶æ‡¶≤‡¶ï‡¶æ ‡¶®‡ßÄ‡¶≤ ‡¶∞‡¶Ç */
.tide-info.low-magnitude {
    color: #81d4fa; 
}


.tide-time {
    font-size: 1.1em;
    font-weight: bold;
    color: #ffd700;
    margin-left: 10px; 
}

.tide-entry-current {
    background-color: rgba(255, 255, 255, 0.15); 
    border-radius: 4px;
    padding-left: 5px;
    padding-right: 5px;
    margin: 2px 0;
}

.wave-icon {
    margin-right: 8px;
    font-size: 1.1em;
    color: #81d4fa; 
}

.indicator-arrow {
    font-size: 1.2em;
    margin-left: 5px;
    line-height: 1; 
}

.level-container {
    width: 28px; 
    height: 100%; 
    background-color: #4a7582;
    border-radius: 14px;
    overflow: hidden;
    position: relative;
    box-shadow: inset 0 0 5px rgba(0, 0, 0, 0.2);
    border: 2px solid rgba(255, 255, 255, 0.1);
}

.level-bar {
    width: 100%;
    background: linear-gradient(to top, #03a9f4, #81d4fa); 
    position: absolute;
    bottom: 0;
    height: 0%; 
    transition: height 1s ease-in-out;
}

.level-percent {
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%) rotate(-90deg);
    color: #fff; 
    font-size: 0.9em;
    font-weight: bold;
    width: 100px;
    text-align: center;
    text-shadow: 0 0 3px rgba(0, 0, 0, 0.5); 
}

.widget-footer {
    border-top: 1px solid rgba(255, 255, 255, 0.2);
    padding-top: 10px;
    margin-top: 10px;
    font-size: 0.85em;
    color: #cfd8dc;
    text-align: center;
}

.widget-footer strong {
    color: #ffeb3b;
}

.bengali-number {
    font-family: 'Noto Sans Bengali', sans-serif; 
}
</style>

<script>
// ---------------------------------
// JavaScript: ‡¶≤‡¶ú‡¶ø‡¶ï‡ßç‡¶Ø‡¶æ‡¶≤ ‡¶è‡¶¨‡¶Ç ‡¶∏‡¶æ‡¶á‡¶®‡ßç‡¶ü‡¶ø‡¶´‡¶ø‡¶ï‡¶æ‡¶≤‡¶ø ‡¶´‡¶ø‡¶ï‡ßç‡¶∏ ‡¶ï‡¶∞‡¶æ ‡¶π‡¶Ø‡¶º‡ßá‡¶õ‡ßá
// ---------------------------------

const STATE = {
    lat: 22.5726, // Kolkata
    lng: 88.3639, // Kolkata
    city: "Kolakata",
    tides: [],
    level: 50,
    isApiWorking: true,
    levelChangeText: '‡¶ú‡¶≤‡¶∏‡ßç‡¶§‡¶∞ ‡¶∏‡ßç‡¶•‡¶ø‡¶§‡¶ø‡¶∂‡ßÄ‡¶≤',
    moonPhaseFactor: 1.0 // 1.0 is neutral, >1.0 for spring tide, <1.0 for neap tide
};

// Data Source API (Free)
const TIDE_API_PRIMARY = `https://tide.dynv6.net/api/tide?lat=${STATE.lat}&lng=${STATE.lng}`;
const MOON_API = `https://api.open-meteo.com/v1/forecast?latitude=${STATE.lat}&longitude=${STATE.lng}&daily=moon_phase&timezone=auto`;

// Caching variables
const CACHE_KEY = 'tideWidgetData';
// **‡¶™‡¶∞‡¶ø‡¶¨‡¶∞‡ßç‡¶§‡¶®:** ‡¶ï‡ßç‡¶Ø‡¶æ‡¶∂ ‡¶è‡¶ñ‡¶® ‡ß®‡ß™ ‡¶ò‡¶£‡ßç‡¶ü‡¶æ ‡¶ï‡¶∞‡¶æ ‡¶π‡¶≤‡ßã (24 * 60 * 60 * 1000 ‡¶Æ‡¶ø‡¶≤‡¶ø‡¶∏‡ßá‡¶ï‡ßá‡¶®‡ßç‡¶°)
const CACHE_EXPIRY_MS = 24 * 60 * 60 * 1000; 

let updateUIInterval; 
let updateDataInterval; 

// --- Utility Functions ---
function getBengaliTime(date) {
    const options = { hour: '2-digit', minute: '2-digit', hour12: true };
    return new Date(date).toLocaleString('bn-IN', options)
        .replace(/AM/, ' AM').replace(/PM/, ' PM');
}

function getBengaliDate(date) {
    const d = new Date(date);
    const options = { day: '2-digit', month: '2-digit', year: 'numeric' };
    return d.toLocaleString('bn-IN', options).replace(/\//g, '-');
}

function toBengaliNumber(num) {
    const map = ['‡ß¶', '‡ßß', '‡ß®', '‡ß©', '‡ß™', '‡ß´', '‡ß¨', '‡ß≠', '‡ßÆ', '‡ßØ'];
    return String(num).split('').map(char => map[parseInt(char)] || char).join('');
}

// --- Caching Logic ---
function getCachedData() {
    try {
        const cachedData = localStorage.getItem(CACHE_KEY);
        if (!cachedData) return null;

        const data = JSON.parse(cachedData);
        // Check if the timestamp is still in the future
        if (data.timestamp && data.timestamp > new Date().getTime()) {
            return data.tides;
        }
        return null;
    } catch (e) {
        return null;
    }
}

function setCachedData(tides) {
    try {
        const expiryTimestamp = new Date().getTime() + CACHE_EXPIRY_MS;
        const data = {
            timestamp: expiryTimestamp,
            tides: tides
        };
        localStorage.setItem(CACHE_KEY, JSON.stringify(data));
    } catch (e) {
        console.error("Error setting cached data:", e);
    }
}

// --- ULTIMATE FALLBACK DATA (Level 3 Fallback - Scientific Average) ---
function getLocalFallbackTides() {
    // ‡¶ï‡¶≤‡¶ï‡¶æ‡¶§‡¶æ‡¶∞ ‡¶ú‡¶®‡ßç‡¶Ø ‡¶Ü‡¶®‡ßÅ‡¶Æ‡¶æ‡¶®‡¶ø‡¶ï ‡¶ó‡¶°‡¶º ‡¶∏‡¶Æ‡¶Ø‡¶º: 1AM-‡¶è High Tide ‡¶ß‡¶∞‡ßá, ‡¶ó‡¶°‡¶º 6h 12.5m ‡¶™‡¶∞ ‡¶™‡¶∞
    const now = new Date();
    
    // ‡¶∂‡ßÅ‡¶∞‡ßÅ ‡¶ï‡¶∞‡¶æ‡¶∞ ‡¶ú‡¶®‡ßç‡¶Ø ‡¶Ü‡¶ú‡¶ï‡ßá‡¶∞ ‡¶∏‡¶¨‡¶ö‡ßá‡¶Ø‡¶º‡ßá ‡¶ï‡¶æ‡¶õ‡ßá‡¶∞ High Tide ‡¶∏‡¶Æ‡¶Ø‡¶º ‡¶ñ‡ßÅ‡¶Å‡¶ú‡ßá ‡¶¨‡ßá‡¶∞ ‡¶ï‡¶∞‡¶æ
    const avgTideCycleDurationMs = 6 * 60 * 60 * 1000 + 12.5 * 60 * 1000;
    const todayStart = new Date(now.getFullYear(), now.getMonth(), now.getDate(), 0, 0, 0).getTime();
    
    let baseTime = new Date(now.getFullYear(), now.getMonth(), now.getDate(), 1, 0, 0).getTime(); 

    // Find the closest past HHW
    while (baseTime > now.getTime()) {
        baseTime -= avgTideCycleDurationMs * 2; // Subtract two cycles to go back to the first HHW of the day
    }
    
    // Generate up to 6 events (covering roughly 30 hours)
    const tides = [];
    let currentTime = baseTime;
    
    for (let i = 0; i < 6; i++) {
        const typeIndex = i % 4;
        let type;
        if (typeIndex === 0 || typeIndex === 2) { // 0, 2 are High Tides
            type = 'High';
        } else { // 1, 3 are Low Tides
            type = 'Low';
        }

        // Apply 6h 12.5m time difference
        if(i > 0) {
            currentTime += avgTideCycleDurationMs;
        }
        
        tides.push({ time: new Date(currentTime).toISOString(), type: type });
    }
    
    // Only return tides that are relevant (from the closest event onwards, covering ~24h)
    return tides.filter(tide => new Date(tide.time) > new Date().getTime() - (3 * 60 * 60 * 1000));
}

// --- Moon Phase Calculation (Level 2 Fallback) ---
async function fetchMoonPhase() {
    try {
        const response = await fetch(MOON_API);
        if (!response.ok) throw new Error('Moon API failed');
        const data = await response.json();
        
        const moonCode = data.daily.moon_phase[0]; 
        
        let factor = 1.0;
        // Spring Tide (Full/New Moon) - Higher Range
        if (moonCode <= 1 || moonCode >= 23 || (moonCode >= 11 && moonCode <= 13)) {
            factor = 1.3; 
        } 
        // Neap Tide (Quarter Moon) - Lower Range
        else if ((moonCode >= 5 && moonCode <= 7) || (moonCode >= 17 && moonCode <= 19)) {
            factor = 0.7; 
        }
        STATE.moonPhaseFactor = factor;
    } catch (e) {
        STATE.moonPhaseFactor = 1.0; // Default factor if moon API fails
    }
}

// --- UI Building Functions ---
function buildTideList(tides) {
    // If API/Cache failed, use the Local Fallback Data
    const dataTides = (tides && tides.length > 0) ? tides : getLocalFallbackTides();
    
    let html = '';
    const now = new Date();
    let isCurrentTideFound = false;
    
    // Logic for four alternating states (HHW, LHW, LLW, HLW)
    let highCount = 0; 
    let lowCount = 0;  
    const waterIcon = '<span class="wave-icon">‚âà</span>'; 

    // Only display up to 6 upcoming events
    const displayTides = dataTides
        .filter(tide => new Date(tide.time) > new Date().getTime() - (12 * 60 * 60 * 1000)) // Start from slightly past now
        .slice(0, 6); // Limit to 6 events

    displayTides.forEach((tide, index) => {
        const tideTime = new Date(tide.time);
        const timeStr = getBengaliTime(tide.time);
        
        let typeStr;
        let magnitudeClass = ''; 
        let arrowIcon = ''; 
        
        // This is the correct logic for Diurnal/Mixed tides
        if (tide.type.toLowerCase() === 'high') {
            if (highCount % 2 === 0) {
                typeStr = '‡¶â‡¶ö‡ßç‡¶ö ‡¶ú‡ßã‡¶Ø‡¶º‡¶æ‡¶∞'; // HHW (First/Higher High)
            } else {
                typeStr = '‡¶®‡¶ø‡¶Æ‡ßç‡¶® ‡¶ú‡ßã‡¶Ø‡¶º‡¶æ‡¶∞'; // LHW (Second/Lower High - Still high, but lower than HHW)
                magnitudeClass = 'low-magnitude'; 
            }
            arrowIcon = '<span class="indicator-arrow arrow-up">‚ñ≤</span>'; 
            highCount++;
        } else {
            if (lowCount % 2 === 0) {
                typeStr = '‡¶®‡¶ø‡¶Æ‡ßç‡¶® ‡¶≠‡¶æ‡¶ü‡¶æ'; // LLW (First/Lower Low)
            } else {
                typeStr = '‡¶â‡¶ö‡ßç‡¶ö ‡¶≠‡¶æ‡¶ü‡¶æ'; // HLW (Second/Higher Low - Still low, but higher than LLW)
                magnitudeClass = 'low-magnitude'; 
            }
            arrowIcon = '<span class="indicator-arrow arrow-down">‚ñº</span>';
            lowCount++;
        }

        // Highlight the NEXT upcoming event
        let isCurrent = !isCurrentTideFound && tideTime > now;
        if (isCurrent) {
            isCurrentTideFound = true;
        }

        const currentArrow = isCurrent ? arrowIcon : ''; 
        
        // Skip the current highlight on the first informational line
        const isInfoLine = (index === 0 && !isCurrentTideFound);

        html += `
            <div class="tide-entry ${isCurrent ? 'tide-entry-current' : ''}">
                <div class="tide-info ${magnitudeClass}">
                    ${waterIcon} ${typeStr}
                </div>
                <div class="tide-time bengali-number">
                    ${timeStr} ${currentArrow}
                </div>
            </div>
        `;
    });
    
    // Current Phase Display (Top line with percentage)
    let currentPhaseHTML = '';
    const effectiveTidesCheck = tides.length > 0 ? tides : getLocalFallbackTides();

    if (effectiveTidesCheck.length > 0) {
        let currentStatus = STATE.levelChangeText;
        let changeIcon = '';
        if (currentStatus.includes('‡¶ú‡ßã‡¶Ø‡¶º‡¶æ‡¶∞‡ßá‡¶∞ ‡¶¶‡¶ø‡¶ï‡ßá')) {
            changeIcon = 'üî∫';
        } else if (currentStatus.includes('‡¶≠‡¶æ‡¶ü‡¶æ‡¶∞ ‡¶¶‡¶ø‡¶ï‡ßá')) {
            changeIcon = 'üîª';
        } else if (currentStatus.includes('‡¶∏‡ßç‡¶•‡¶ø‡¶§‡¶ø‡¶∂‡ßÄ‡¶≤')) {
            changeIcon = 'üíß';
        }
        
        currentPhaseHTML = `
            <div class="tide-entry tide-entry-current" style="background-color: rgba(255, 255, 255, 0.25); border-radius: 4px; padding: 10px 5px; margin-bottom: 5px; border-top: none;">
                <div class="tide-info" style="font-weight: bold; color: #ffeb3b;">
                    ${changeIcon} ${currentStatus}
                </div>
                <div class="tide-time bengali-number">
                    ${toBengaliNumber(Math.round(STATE.level))}%
                </div>
            </div>
        `;
    }
    
    return currentPhaseHTML + html; 
}

function updateLevelUI(currentLevel) {
    const levelBar = document.getElementById('level-bar');
    const levelPercent = document.getElementById('level-percent');

    if (levelBar && levelPercent) {
        const percentage = Math.max(0, Math.min(100, Math.round(currentLevel)));
        levelBar.style.height = `${percentage}%`;
        levelPercent.textContent = `${toBengaliNumber(percentage)}%`;
    }
}

// **Scientific Fix:** Uses Cosine wave logic for smooth transition between events
function updateLevelAndPhase(tides) {
    const now = new Date().getTime();
    let lastTide = null;
    let nextTide = null;
    let levelPercent = 50; 
    
    // Use effective tides (API, Cache, or Local Fallback)
    const effectiveTides = tides.length > 0 ? tides : getLocalFallbackTides();
    
    // Find the last event and the next event
    if (effectiveTides.length > 0) {
        for (let i = 0; i < effectiveTides.length; i++) {
            const tideTime = new Date(effectiveTides[i].time).getTime();
            if (tideTime < now) {
                lastTide = effectiveTides[i];
            } else {
                nextTide = effectiveTides[i];
                break;
            }
        }
        
        if (lastTide && nextTide) {
            const lastTime = new Date(lastTide.time).getTime();
            const nextTime = new Date(nextTide.time).getTime();
            const duration = nextTime - lastTime;
            const elapsed = now - lastTime;
            let ratio = elapsed / duration;
            
            if (ratio > 1) ratio = 1;
            if (ratio < 0) ratio = 0;

            // Normalize tide types for calculation: High=100%, Low=0%
            let startLevel = lastTide.type.toLowerCase() === 'high' ? 100 : 0;
            let endLevel = nextTide.type.toLowerCase() === 'high' ? 100 : 0;
            
            // Cosine wave transition
            if (startLevel === 0 && endLevel === 100) {
                // Low to High (Rising)
                levelPercent = 50 * (1 - Math.cos(ratio * Math.PI)) + 50 * 0; 
                STATE.levelChangeText = '‡¶â‡¶ö‡ßç‡¶ö ‡¶ú‡ßã‡¶Ø‡¶º‡¶æ‡¶∞‡ßá‡¶∞ ‡¶¶‡¶ø‡¶ï‡ßá'; 
            } else if (startLevel === 100 && endLevel === 0) {
                // High to Low (Falling)
                levelPercent = 50 * (1 + Math.cos(ratio * Math.PI)); 
                STATE.levelChangeText = '‡¶®‡¶ø‡¶Æ‡ßç‡¶® ‡¶≠‡¶æ‡¶ü‡¶æ‡¶∞ ‡¶¶‡¶ø‡¶ï‡ßá'; 
            } else {
                // High to High or Low to Low (Shouldn't happen with correct data, but for safety)
                levelPercent = startLevel + (endLevel - startLevel) * ratio;
                STATE.levelChangeText = '‡¶ú‡ßã‡¶Ø‡¶º‡¶æ‡¶∞-‡¶≠‡¶æ‡¶ü‡¶æ‡¶∞ ‡¶Æ‡¶ß‡ßç‡¶Ø‡¶¨‡¶∞‡ßç‡¶§‡ßÄ';
            }
            
            // Adjust level using the Moon Phase Factor to reflect Spring/Neap Tides (Range adjustment)
            const baseFactor = 1.1; 
            const finalFactor = baseFactor * STATE.moonPhaseFactor; 
            
            // Adjust the 0-100% range based on the finalFactor
            const adjustedLevel = (levelPercent / 100 - 0.5) * 2 * finalFactor; // Scale to -1 to 1, then apply factor
            STATE.level = Math.max(0, Math.min(100, (adjustedLevel / 2 + 0.5) * 100)); // Scale back to 0-100%

        } else {
             // If only one or no event is found (very rare), default to a stable level
             STATE.level = lastTide ? (lastTide.type.toLowerCase() === 'high' ? 95 : 5) : 50;
             STATE.levelChangeText = '‡¶ú‡¶≤‡¶∏‡ßç‡¶§‡¶∞ ‡¶∏‡ßç‡¶•‡¶ø‡¶§‡¶ø‡¶∂‡ßÄ‡¶≤';
        }
    } else {
         STATE.level = 50;
         STATE.levelChangeText = '‡¶ú‡¶≤‡¶∏‡ßç‡¶§‡¶∞ ‡¶∏‡ßç‡¶•‡¶ø‡¶§‡¶ø‡¶∂‡ßÄ‡¶≤';
    }

    updateLevelUI(STATE.level);
}


function buildWidget(state) {
    const tideListContainer = document.getElementById('tide-list-container');
    const dateDisplay = document.getElementById('current-date-display');
    const timeDisplay = document.getElementById('local-time-display');
    const locationName = document.getElementById('location-name');
    const warningDiv = document.getElementById('api-key-warning');
    const levelTitle = document.querySelector('.level-title-flex .tide-title-sub');
    
    document.getElementById('loading-message').style.display = 'none';

    if (tideListContainer) {
        tideListContainer.innerHTML = buildTideList(state.tides);
    } 
    
    if (levelTitle) {
        levelTitle.textContent = state.levelChangeText;
    }
    
    if (dateDisplay) dateDisplay.textContent = getBengaliDate(new Date());
    if (timeDisplay) timeDisplay.textContent = getBengaliTime(new Date());
    if (locationName) locationName.textContent = state.city;
    
    // Warning Message Logic: Only show if the primary API failed (tides.length === 0)
    if (state.tides.length === 0) {
        warningDiv.style.display = 'block';
        warningDiv.textContent = '‡¶ú‡ßã‡¶Ø‡¶º‡¶æ‡¶∞-‡¶≠‡¶æ‡¶ü‡¶æ‡¶∞ ‡¶§‡¶•‡ßç‡¶Ø ‡¶¨‡¶∞‡ßç‡¶§‡¶Æ‡¶æ‡¶®‡ßá ‡¶≤‡ßã‡¶° ‡¶π‡¶ö‡ßç‡¶õ‡ßá ‡¶®‡¶æ (‡¶´‡¶≤‡¶¨‡ßç‡¶Ø‡¶æ‡¶ï ‡¶°‡ßá‡¶ü‡¶æ ‡¶¨‡ßç‡¶Ø‡¶¨‡¶π‡ßÉ‡¶§ ‡¶π‡¶ö‡ßç‡¶õ‡ßá)';
    } else {
        warningDiv.style.display = 'none';
    }
}


// --- Data Fetching Logic (Triple Fallback) ---
async function loadAllData() {
    document.getElementById('loading-message').style.display = 'block';
    STATE.tides = [];
    
    // 1. Fetch Moon Phase (Level 2)
    await fetchMoonPhase();

    // 2. Try loading from Cache (Level 1.5)
    const cachedTides = getCachedData();
    if (cachedTides) {
        STATE.tides = cachedTides;
    }

    // 3. Try fetching fresh data from the Primary API (dynv6) (Level 1)
    let freshTides = [];
    try {
        const tideResponse = await fetch(TIDE_API_PRIMARY);
        if (!tideResponse.ok) throw new Error('Primary API call failed');
        const tideData = await tideResponse.json();
        freshTides = tideData.tides || [];
        
        if (freshTides.length > 0) {
            STATE.tides = freshTides; // Use fresh data
            setCachedData(freshTides); // Cache the fresh data
        } else {
             throw new Error('API returned no tide data.');
        }
    } catch (e) {
        console.warn("Fresh data fetch failed:", e);
        // If fetch fails, STATE.tides remains empty, triggering the local fallback.
    }
    
    updateLevelAndPhase(STATE.tides);
    document.getElementById('loading-message').style.display = 'none';
    buildWidget(STATE);
}

// 30 ‡¶∏‡ßá‡¶ï‡ßá‡¶®‡ßç‡¶° ‡¶Ö‡¶®‡ßç‡¶§‡¶∞ UI ‡¶Ü‡¶™‡¶°‡ßá‡¶ü (‡¶∏‡¶Æ‡ßü ‡¶è‡¶¨‡¶Ç ‡¶ú‡¶≤‡¶∏‡ßç‡¶§‡¶∞)
function updateUI() {
    const timeDisplay = document.getElementById('local-time-display');
    if (timeDisplay) timeDisplay.textContent = getBengaliTime(new Date());

    updateLevelAndPhase(STATE.tides);
    
    buildWidget(STATE);
}

function initializeWidget() {
    loadAllData(); // Initial load
    updateUIInterval = setInterval(updateUI, 30000); // UI update every 30 seconds
    // **‡¶™‡¶∞‡¶ø‡¶¨‡¶∞‡ßç‡¶§‡¶®:** ‡¶´‡ßÅ‡¶≤ ‡¶°‡¶æ‡¶ü‡¶æ ‡¶∞‡¶ø‡¶≤‡ßã‡¶° ‡¶è‡¶ñ‡¶® ‡ß®‡ß™ ‡¶ò‡¶£‡ßç‡¶ü‡¶æ ‡¶™‡¶∞ ‡¶™‡¶∞ ‡¶π‡¶¨‡ßá
    updateDataInterval = setInterval(loadAllData, CACHE_EXPIRY_MS); 
}

window.onload = initializeWidget; 
</script>
